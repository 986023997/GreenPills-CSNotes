# 其他类问题汇总

## 1.windows下1GB的文件要进行序列的变化，第一个和倒数第一个交换，第二个和倒数第二个交换，该怎么处理。

## 2.有序循环数组查找最小值，[4,5,1,2,3]找到1

## 3.有序单链表去重

## 4.假设有20个银币1个金币，你和你的同伙分赃，每次可拿走1～4个硬币，当银币全部拿出后才可以拿金币。请问你怎么拿才可以保证金币属于你？

## 5.如何判断链表是否有环，判断环的长度。

快慢指针：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指针走到了链表的末尾（next指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。
map：如果不考虑空间复杂度，可以使用一个map记录走过的节点，当遇到第一个在map中存在的节点时，就说明回到了出发点，即链表有环，同时也找到了环的入口。

所以寻找环入口的方法就是采用两个指针，一个从表头出发，一个从相遇点出发，一次都只移动一步，当二者相等时便是环入口的位置。

## 6.如何判断链表是否相交

我们可以从头遍历两个链表。创建两个栈，第一个栈存储第一个链表的节点，第二个栈存储第二个链表的节点。每遍历到一个节点时，就将该节点入栈。两个链表都入栈结束后。则通过top判断栈顶的节点是否相等即可判断两个单链表是否相交。因为我们知道，若两个链表相交，则从第一个相交节点开始，后面的节点都相交。
若两链表相交，则循环出栈，直到遇到两个出栈的节点不相同，则这个节点的后一个节点就是第一个相交的节点。

- 遍历链表记录长度。
同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。 
有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。 
则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。

## 7.如何用两个栈实现一个队列

## 8.一个整数数组，一个整数n，如何判断数组中是否存在两个数的和等于n

## 9.有m个玩家，取游戏排行榜中排名前k的玩家进行决斗，如何选取

## 10. 如何通过c/c++判断不同的操作系统位数，32位还是64位。

通过sizeof可以判断。32位系统上，指针和long类型都是32位；而在64位系统上，指针和long类型都是64位的。但是这种方法其实是判断编译器类型的，因为在64位操作系统下使用32位编译器不会和32位操作系统下使用32位编译器有什么区别。

## 11.如果进程有优先级，不超过256，要按照进程优先级调度（假设这些进程都是就绪的），你用什么数据结构。

## 12.写代码需要注意什么

## 13.设计一个cache，大小有2G，用途是向外部提供查询服务（查询内容是长度不等的串），衡量指标是数量命中率和命中内容大小。

## 14.rabbitmq的架构，同步还是异步，有什么优势

1. 优势（为什么使用消息队列）：

    - 解耦

    传统模式的缺点：系统间耦合性太强，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！
    中间件模式的优点：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。

    - 异步

    传统模式的缺点：一些非必要的业务逻辑以同步的方式运行，太耗费时间。
    中间件模式的优点：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快相应速度

    - 削峰
    传统模式的缺点：并发量大的时间，所有的请求直接怼到数据库，造成数据库连接异常
    中间件模式的优点：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。

2. 缺点

    - 系统可用性降低：

    你想呀，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低

    - 系统复杂性增加：

    加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，刺痛复杂性增大。

3. 对比分析

    |特性|ActiveMQ|Rabbitmq|RockerMQ|kafka|
    |--|--|--|--|--|
    |开发语言|java|erlang|java|scala|
    |单机吞吐量|万级|万级|10万级|10万级|
    |时效性|ms级|us级|ms级|ms级以内|
    |可用性|高(主从架构)|高(主从架构)|非常高(分布式架构)|非常高(分布式架构)|
    |功能特性|成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好|基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富|MQ功能比较完备，扩展性佳|只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。|

    中小型软件公司，建议选RabbitMQ.
    一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。
    不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。

4. 如何保证消息队列的高可用性

    rabbitMQ,也有普通集群和镜像集群模式
    RabbitMQ的集群节点包括内存节点、磁盘节点。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。不过，如前文所述，如果在投递消息时，打开了消息的持久化，那么即使是内存节点，数据还是安全的放在磁盘。

    一个rabbitmq集 群中可以共享 user，vhost，queue，exchange等，所有的数据和状态都是必须在所有节点上复制的，一个例外是，那些当前只属于创建它的节点的消息队列，尽管它们可见且可被所有节点读取。rabbitmq节点可以动态的加入到集群中，一个节点它可以加入到集群中，也可以从集群环集群会进行一个基本的负载均衡。
    集群中有两种节点：
    1 内存节点：只保存状态到内存（一个例外的情况是：持久的queue的持久内容将被保存到disk）
    2 磁盘节点：保存状态到内存和磁盘。
    内存节点虽然不写入磁盘，但是它执行比磁盘节点要好。集群中，只需要一个磁盘节点来保存状态 就足够了
    如果集群中只有内存节点，那么不能停止它们，否则所有的状态，消息等都会丢失。

    - 普通模式：默认的集群模式。
        对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构。
        当消息进入A节点的Queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。
        所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连A或B，出口总在A，会产生瓶颈。
        该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。
        如果做了消息持久化，那么得等A节点恢复，然后才可被消费；如果没有持久化的话，然后就没有然后了……

    - 镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。
        该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。
        该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。
        所以在对可靠性要求较高的场合中适用(后面会详细介绍这种模式，目前我们搭建的环境属于该模式)

    - 集群模式配置
        设计架构可以如下：在一个集群里，有4台机器，其中1台使用磁盘模式，另2台使用内存模式。2台内存模式的节点，无疑速度更快，因此客户端（consumer、producer）连接访问它们。而磁盘模式的节点，由于磁盘IO相对较慢，因此仅作数据备份使用，另外一台作为反向代理。

5. 如何保证消息不被重复消费

    其实无论是哪种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。RabbitMQ是发送一个ACK确认消息。

    （1）比如，你拿到这个消息做数据库的insert操作，那就容易了，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。

    （2）再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。

    （3）如果上面两种情况还不行，上大招。准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<id,message>以K-V形式写入redis.那消费者开始消费前，先去redis中查询有没有消费记录即可。

6. 如何保证消费的可靠性传输？

    - 生产者丢数据
        从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。

        transaction机制就是说，发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。

        然而，这种方式有个缺点：吞吐量下降。因为，按照经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。处理Ack和Nack的代码如下所示：

    - 消息队列丢数据

        处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

        那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步

        将queue的持久化标识durable设置为true,则代表是一个持久的队列
        发送消息的时候将deliveryMode=2
        这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据

    - 消费者丢数据

        消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rabbitMQ会立即将消息删除，这种情况下，如果消费者出现异常而未能处理消息，就会丢失该消息。
        至于解决方案，采用手动确认消息即可。

## 15.人口预测模型

- 马尔萨斯人口模型
  函数模型人口数量是时间变量的指数函数，成指数增长。
  因此，遵循马尔萨斯生物总数增长定律得任何生物都是随时间按指数方式增长，在此意义下，马尔萨斯方程（1）又称指数增长模型。人作为特殊的生物总群，人口的增长也应满足马尔萨斯生物总数增长定律，此时的（1）式称为马尔萨斯人口方程。
- logistic曲线模型
  有压力的人口预测模型，在一定的环境中种群的增长是具有上限的。种群数量逐渐向着上限上升的时实际的增长率会逐渐减少。
- Leslie矩阵模型
  依种群个体的生理特征,将其最大寿命年龄等距分成m个年龄组,然后讨论不同时间种群按年龄的分布,故时间也离散化为t=0,1,2,…其间隔与年龄组的间隔时间相同.t=0对应于初始时刻.
  (1) 将时间离散化，假设男女人口的性别比为1:2/年观察一次，不考虑同一时间间隔内人口数量的变化;

## 16.为什么选用postgressql数据库

1. postgres是开源免费软件，我们并不希望为数据库付费。同时我们的项目的数据量在十万级，轻量级的数据库就可以搞定，所以我们基本上用mysql或者postgres就可以搞定。

2. 支持非常多种数据类型，除了常见的numeric， floating-point， string， boolean 等，还支持network address（网络地址类型）、几何类型（包括point、line、box、circle）,我们需要存储一些几何形状，因此有这种数据支持很有吸引力的。

3. 使用一个数据库会遇到各类问题，postgres的社区非常好，遇到问题都可以去postgres社区寻求帮助。（讲故事：数据库量级千万，根据时间查询最近200条，耗时长，通过社区提问对该字段添加索引，效果提高非常多）

4. 相对而言比较稳定。