# 微信面试

1. 数学建模大赛有什么挑战。
2. 讲一个你值得讲的项目。
3. 有什么智能指针。

    当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。

    将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。

    STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr（本文章暂不讨论）。
    模板auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，并提供了另外两种解决方案。然而，虽然auto_ptr被摒弃，但它已使用了好多年：同时，如果您的编译器不支持其他两种解决力案，auto_ptr将是唯一的选择。

    - shared_ptr
    当多个shared_ptr管理同一个指针，仅当最后一个shared_ptr析构时，指针才被delete。引用计数指的是，所有管理同一个裸指针（raw pointer）的shared_ptr，都共享一个引用计数器，每当一个shared_ptr被赋值（或拷贝构造）给其它shared_ptr时，这个共享的引用计数器就加1，当一个shared_ptr析构或者被用于管理其它裸指针时，这个引用计数器就减1，如果此时发现引用计数器为0，那么说明它是管理这个指针的最后一个shared_ptr了，于是我们释放指针指向的资源。

4. 有什么迭代器。
5. 深拷贝、浅拷贝。
6. 堆栈内存分配。
7. 动态规划了解吗。
8. windows下1GB的文件要进行序列的变化，第一个和倒数第一个交换，第二个和倒数第二个交换，该怎么处理。
9. 线程方面遇到过什么问题。
10. 看什么技术类的书籍。
11. 有序循环数组查找最小值，[4,5,1,2,3]找到1
12. 有序单链表去重
13. 假设有20个银币1个金币，你和你的同伙分赃，每次可拿走1～4个硬币，当银币全部拿出后才可以拿金币。请问你怎么拿才可以保证金币属于你？
14. c++11